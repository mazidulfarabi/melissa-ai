const fetch = require('node-fetch');

exports.handler = async function(event, context) {
  // Handle CORS preflight requests
  if (event.httpMethod === 'OPTIONS') {
    return {
      statusCode: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Headers": "Content-Type",
        "Access-Control-Allow-Methods": "POST, OPTIONS"
      },
      body: ""
    };
  }

  // Health check endpoint
  if (event.httpMethod === 'GET') {
    return {
      statusCode: 200,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        status: "healthy",
        timestamp: new Date().toISOString(),
        hasPrimaryApiKey: !!process.env.OPENROUTER_API_KEY,
        hasBackupApiKey: !!process.env.OPENROUTER_API_KEY_BACKUP,
        primaryApiKeyLength: process.env.OPENROUTER_API_KEY ? process.env.OPENROUTER_API_KEY.length : 0,
        backupApiKeyLength: process.env.OPENROUTER_API_KEY_BACKUP ? process.env.OPENROUTER_API_KEY_BACKUP.length : 0,
        primaryApiKeyPrefix: process.env.OPENROUTER_API_KEY ? process.env.OPENROUTER_API_KEY.substring(0, 10) + '...' : 'none',
        backupApiKeyPrefix: process.env.OPENROUTER_API_KEY_BACKUP ? process.env.OPENROUTER_API_KEY_BACKUP.substring(0, 10) + '...' : 'none',
        environment: process.env.NODE_ENV || 'development'
      })
    };
  }

  try {
    // Check if at least one API key is available
    if (!process.env.OPENROUTER_API_KEY && !process.env.OPENROUTER_API_KEY_BACKUP) {
      console.error('Missing both OPENROUTER_API_KEY and OPENROUTER_API_KEY_BACKUP environment variables');
      return {
        statusCode: 500,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          error: "Configuration error",
          response: "ржЖржорж┐ ржПржЦржи рж╕ржарж┐ржХржнрж╛ржмрзЗ ржХржиржлрж┐ржЧрж╛рж░ ржХрж░рж╛ ржирзЗржЗред ржжржпрж╝рж╛ ржХрж░рзЗ рж╕рж╛ржкрзЛрж░рзНржЯрзЗ ржпрзЛржЧрж╛ржпрзЛржЧ ржХрж░рзБржиред"
        })
      };
    }

    // Validate API key formats
    const primaryKeyValid = process.env.OPENROUTER_API_KEY && process.env.OPENROUTER_API_KEY.startsWith('sk-');
    const backupKeyValid = process.env.OPENROUTER_API_KEY_BACKUP && process.env.OPENROUTER_API_KEY_BACKUP.startsWith('sk-');
    
    if (!primaryKeyValid && !backupKeyValid) {
      console.error('Invalid API key format - both keys should start with sk-');
      return {
        statusCode: 500,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          error: "Invalid API key format",
          response: "ржЖржорж╛рж░ API ржХрзАржЧрзБрж▓рж┐ рж╕ржарж┐ржХржнрж╛ржмрзЗ ржХржиржлрж┐ржЧрж╛рж░ ржХрж░рж╛ ржирзЗржЗред ржжржпрж╝рж╛ ржХрж░рзЗ рж╕рзЗржЯржЖржк ржЪрзЗржХ ржХрж░рзБржиред"
        })
      };
    }

    const { message, history, image } = JSON.parse(event.body || '{}');

    if (!message && !image) {
      return {
        statusCode: 400,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ error: "Message or image is required" })
      };
    }

    console.log('Starting API request...');
    console.log('Primary API Key present:', !!process.env.OPENROUTER_API_KEY);
    console.log('Backup API Key present:', !!process.env.OPENROUTER_API_KEY_BACKUP);
    console.log('User message:', message);
    console.log('Chat history length:', history ? history.length : 0);

    // Optimized local response system for common greetings and simple questions so resources are not wasted
    const localResponses = {
      // Greetings
      'hello': [
        "рж╣рзНржпрж╛рж▓рзЛ! ЁЯШК ржХрзЗржоржи ржЖржЫрзЗржи?",
        "рж╣рж╛ржЗ! ржжрзЗржЦрзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯСЛ",
        "рж╣рзНржпрж╛рж▓рзЛ! ржЖржЬ ржХрзЗржоржи ржХрж╛ржЯржЫрзЗ? ЁЯШД"
      ],
      'hi': [
        "рж╣рж╛ржЗ! ржХрж┐ ржЕржмрж╕рзНржерж╛? ЁЯШК",
        "рж╣рзНржпрж╛рж▓рзЛ! ржжрж┐ржи ржХрзЗржоржи ржпрж╛ржЪрзНржЫрзЗ? ЁЯСЛ",
        "рж╣рж╛ржЗ! ржХржерж╛ ржмрж▓рзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯШД"
      ],
      'hey': [
        "рж╣рж╛ржЗ! ржХрзЗржоржи ржЖржЫрзЗржи? ЁЯШК",
        "рж╣рзНржпрж╛рж▓рзЛ! ржХрж┐ ржЦржмрж░? ЁЯСЛ",
        "рж╣рж╛ржЗ! ржжрзЗржЦрзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯШД"
      ],
      'good morning': [
        "рж╕рзБржкрзНрж░ржнрж╛ржд! ржЖрж╢рж╛ ржХрж░рж┐ ржжрж┐ржирзЗрж░ рж╢рзБрж░рзБржЯрж╛ ржнрж╛рж▓рзЛ ржпрж╛ржЪрзНржЫрзЗ! тШАя╕П",
        "рж╕ржХрж╛рж▓! ржПржЦржи ржкрж░рзНржпржирзНржд ржХрзЗржоржи ржпрж╛ржЪрзНржЫрзЗ? ЁЯМЕ",
        "рж╕рзБржкрзНрж░ржнрж╛ржд! ржХржерж╛ ржмрж▓рждрзЗ ржкрзНрж░рж╕рзНрждрзБржд? ЁЯШК"
      ],
      'good afternoon': [
        "рж╢рзБржн ржмрж┐ржХрж╛рж▓! ржЖрж╢рж╛ ржХрж░рж┐ ржжрж┐ржиржЯрж╛ ржнрж╛рж▓рзЛ ржпрж╛ржЪрзНржЫрзЗ! ЁЯМЮ",
        "ржмрж┐ржХрж╛рж▓! рж╕ржм ржХрзЗржоржи? ЁЯШК",
        "рж╢рзБржн ржмрж┐ржХрж╛рж▓! ржжрзЗржЦрзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯСЛ"
      ],
      'good evening': [
        "рж╢рзБржн рж╕ржирзНржзрзНржпрж╛! ржжрж┐ржиржЯрж╛ ржХрзЗржоржи ржЫрж┐рж▓? ЁЯМЩ",
        "рж╕ржирзНржзрзНржпрж╛! ржЖрж╢рж╛ ржХрж░рж┐ ржнрж╛рж▓рзЛ ржжрж┐ржи ржХрж╛ржЯрж┐ржпрж╝рзЗржЫрзЗржи! ЁЯШК",
        "рж╢рзБржн рж╕ржирзНржзрзНржпрж╛! ржХржерж╛ ржмрж▓рждрзЗ ржкрзНрж░рж╕рзНрждрзБржд? ЁЯСЛ"
      ],
      'good night': [
        "рж╢рзБржн рж░рж╛рждрзНрж░рж┐! ржорж┐рж╖рзНржЯрж┐ рж╕рзНржмржкрзНржи! ЁЯШ┤",
        "рж░рж╛ржд! ржнрж╛рж▓рзЛ ржШрзБржо! ЁЯМЩ",
        "рж╢рзБржн рж░рж╛рждрзНрж░рж┐! ржЖржЧрж╛ржорзАржХрж╛рж▓ ржжрзЗржЦрж╛ рж╣ржмрзЗ! ЁЯШК"
      ],
      
      // How are you variations
      'how are you': [
        "ржЖржорж┐ ржЦрзБржм ржнрж╛рж▓рзЛ! ржЬрж┐ржЬрзНржЮрзЗрж╕ ржХрж░рж╛рж░ ржЬржирзНржп ржзржирзНржпржмрж╛ржж! ржЖржкржирж┐ ржХрзЗржоржи? ЁЯШК",
        "ржЖржорж┐ ржжрж╛рж░рзБржг! ржЖржкржирж┐ ржХрзЗржоржи ржЖржЫрзЗржи? ЁЯШД",
        "ржЖржорж┐ ржнрж╛рж▓рзЛ ржЖржЫрж┐! ржЖржкржирж╛рж░ ржжрж┐ржи ржХрзЗржоржи ржпрж╛ржЪрзНржЫрзЗ? ЁЯШК"
      ],
      'how r u': [
        "ржЖржорж┐ ржнрж╛рж▓рзЛ! ржЖржкржирж┐ ржХрзЗржоржи? ЁЯШК",
        "ржЖржорж┐ ржжрж╛рж░рзБржг! ржЖржкржирж┐ ржХрзЗржоржи ржЖржЫрзЗржи? ЁЯШД",
        "ржЖржорж┐ ржнрж╛рж▓рзЛ ржЖржЫрж┐! ржХрзЗржоржи ржпрж╛ржЪрзНржЫрзЗ? ЁЯШК"
      ],
      'how are u': [
        "ржЖржорж┐ ржнрж╛рж▓рзЛ! ржЖржкржирж┐ ржХрзЗржоржи? ЁЯШК",
        "ржЖржорж┐ ржжрж╛рж░рзБржг! ржЖржкржирж┐ ржХрзЗржоржи ржЖржЫрзЗржи? ЁЯШД",
        "ржЖржорж┐ ржнрж╛рж▓рзЛ ржЖржЫрж┐! ржХрзЗржоржи ржпрж╛ржЪрзНржЫрзЗ? ЁЯШК"
      ],
      
      // Name questions
      'what is your name': [
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржжрзЗржЦрж╛ ржХрж░рзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯШК",
        "ржЖржорж╛рж░ ржирж╛ржо ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯСЛ",
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯШД"
      ],
      'whats your name': [
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржжрзЗржЦрж╛ ржХрж░рзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯШК",
        "ржЖржорж╛рж░ ржирж╛ржо ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯСЛ",
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯШД"
      ],
      'what\'s your name': [
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржжрзЗржЦрж╛ ржХрж░рзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯШК",
        "ржЖржорж╛рж░ ржирж╛ржо ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯСЛ",
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржЖржкржирж╛рж░ ржирж╛ржо ржХрж┐? ЁЯШД"
      ],
      'who are you': [
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI, ржЖржкржирж╛рж░ рж╕рж╣рж╛ржпрж╝ржХ! ЁЯШК",
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI! ржжрзЗржЦрж╛ ржХрж░рзЗ ржнрж╛рж▓рзЛ рж▓рж╛ржЧржЫрзЗ! ЁЯСЛ",
        "ржЖржорж┐ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ AI, ржХржерж╛ ржмрж▓рждрзЗ ржкрзНрж░рж╕рзНрждрзБржд! ЁЯШД"
      ],
      
      // Simple questions
      'what time is it': [
        `It's ${new Date().toLocaleTimeString('en-US', { hour12: true, hour: "numeric", minute: "numeric" })}! тП░`,
        `The time is ${new Date().toLocaleTimeString('en-US', { hour12: true, hour: "numeric", minute: "numeric" })}! ЁЯХР`,
        `Right now it's ${new Date().toLocaleTimeString('en-US', { hour12: true, hour: "numeric", minute: "numeric" })}! тП░`
      ],
      'what day is it': [
        `Today is ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}! ЁЯУЕ`,
        `It's ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}! ЁЯУЖ`,
        `Today is ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}! ЁЯУЕ`
      ],
      
      // Weather (simple response)
      'how is the weather': [
        "I can't check the weather right now, but I hope it's nice where you are! ЁЯМдя╕П",
        "I don't have weather access, but I hope you're having good weather! тШАя╕П",
        "I can't see the weather, but I hope it's beautiful outside! ЁЯМИ"
      ],
      'weather': [
        "I can't check the weather right now, but I hope it's nice where you are! ЁЯМдя╕П",
        "I don't have weather access, but I hope you're having good weather! тШАя╕П",
        "I can't see the weather, but I hope it's beautiful outside! ЁЯМИ"
      ],
      'raining': [
        "Rainy days can be cozy! тШФ Perfect for staying in and chatting! ЁЯШК",
        "Rain is nature's way of watering the plants! ЁЯМзя╕П Hope you're staying dry! тШВя╕П",
        "Rainy weather is great for reading or watching movies! ЁЯУЪтШФ Stay cozy! ЁЯШК"
      ],
      'rain': [
        "Rainy days can be cozy! тШФ Perfect for staying in and chatting! ЁЯШК",
        "Rain is nature's way of watering the plants! ЁЯМзя╕П Hope you're staying dry! тШВя╕П",
        "Rainy weather is great for reading or watching movies! ЁЯУЪтШФ Stay cozy! ЁЯШК"
      ],
      'sunny': [
        "Sunny days are the best! тШАя╕П Perfect for going outside! ЁЯШК",
        "Beautiful sunny weather! ЁЯМЮ Hope you're enjoying it! ЁЯШД",
        "Sunshine makes everything better! тШАя╕П Have a great day! ЁЯШК"
      ],
      'cold': [
        "Brr! Cold weather calls for hot drinks and warm blankets! тШХЁЯзг Stay warm! ЁЯШК",
        "Cold days are perfect for staying cozy inside! ЁЯПа Hot chocolate time! тШХ",
        "Bundle up and stay warm! ЁЯзе Winter vibes! тЭДя╕ПЁЯШК"
      ],
      'hot': [
        "Hot weather! Stay hydrated and cool! ЁЯТзЁЯМбя╕П Ice cream time! ЁЯНж",
        "It's hot out there! Stay in the shade and drink lots of water! тШАя╕ПЁЯТз",
        "Hot days are perfect for swimming or staying in the AC! ЁЯПКтАНтЩАя╕ПтЭДя╕П Stay cool! ЁЯШК"
      ],
      
      // Goodbye
      'bye': [
        "Bye! It was nice chatting with you! ЁЯСЛ",
        "Goodbye! Hope to see you again soon! ЁЯШК",
        "Bye! Take care! ЁЯСЛ"
      ],
      'goodbye': [
        "Goodbye! It was great talking to you! ЁЯСЛ",
        "See you later! Have a great day! ЁЯШК",
        "Goodbye! Come back soon! ЁЯСЛ"
      ],
      'see you': [
        "See you! It was fun chatting! ЁЯСЛ",
        "See you later! Take care! ЁЯШК",
        "See you! Come back anytime! ЁЯСЛ"
      ],
      
      // Common responses
      'ok': [
        "Ok! ЁЯШК",
        "Alright! ЁЯСН",
        "Got it! ЁЯШД"
      ],
      'okay': [
        "Okay! ЁЯШК",
        "Alright! ЁЯСН",
        "Got it! ЁЯШД"
      ],
      'yes': [
        "Yes! ЁЯШК",
        "Yep! ЁЯСН",
        "Absolutely! ЁЯШД"
      ],
      'no': [
        "No worries! ЁЯШК",
        "That's ok! ЁЯСН",
        "No problem! ЁЯШД"
      ],
      'thanks': [
        "You're welcome! ЁЯШК",
        "No problem! ЁЯСН",
        "Anytime! ЁЯШД"
      ],
      'thank you': [
        "You're welcome! ЁЯШК",
        "No problem! ЁЯСН",
        "Anytime! ЁЯШД"
      ],
      'cool': [
        "Cool! ЁЯШО",
        "Awesome! ЁЯШК",
        "Nice! ЁЯСН"
      ],
      'nice': [
        "Nice! ЁЯШК",
        "Cool! ЁЯШО",
        "Awesome! ЁЯСН"
      ]
    };

    // Function to get a random response from an array
    const getRandomResponse = (responses) => {
      return responses[Math.floor(Math.random() * responses.length)];
    };

    // Function to handle long responses by splitting them appropriately
    const handleLongResponse = (response, maxLength = 600) => {
      if (response.length <= maxLength) {
        return response;
      }
      
      // Try to split at sentence boundaries
      const sentences = response.split(/[.!?]+/);
      let result = '';
      
      for (const sentence of sentences) {
        if ((result + sentence).length <= maxLength) {
          result += sentence + '.';
        } else {
          break;
        }
      }
      
      if (result.length < 100) {
        // If we couldn't get a meaningful response, just truncate at word boundary
        const words = response.split(' ');
        result = '';
        for (const word of words) {
          if ((result + word + ' ').length <= maxLength) {
            result += word + ' ';
          } else {
            break;
          }
        }
        result = result.trim() + '...';
      }
      
      return result + '\n\n(рж╕ржорзНржкрзВрж░рзНржг ржЙрждрзНрждрж░ ржкрзЗрждрзЗ "ржЖрж░ржУ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржмрж▓рзБржи" рж▓рж┐ржЦрзБржи)';
    };

    // Helper function to make API call with fallback
    const makeApiCallWithFallback = async (message, history) => {
      const apiKeys = [];
      
      // Add primary key if valid
      if (process.env.OPENROUTER_API_KEY && process.env.OPENROUTER_API_KEY.startsWith('sk-')) {
        apiKeys.push({ key: process.env.OPENROUTER_API_KEY, name: 'primary' });
      }
      
      // Add backup key if valid
      if (process.env.OPENROUTER_API_KEY_BACKUP && process.env.OPENROUTER_API_KEY_BACKUP.startsWith('sk-')) {
        apiKeys.push({ key: process.env.OPENROUTER_API_KEY_BACKUP, name: 'backup' });
      }

      if (apiKeys.length === 0) {
        throw new Error('No valid API keys available');
      }

      let lastError = null;

      for (const { key, name } of apiKeys) {
        console.log(`Trying ${name} API key...`);
        
        // Try up to 2 times for each key with shorter timeouts to avoid function timeout
        for (let attempt = 1; attempt <= 2; attempt++) {
          try {
            const controller = new AbortController();
            // Increased timeouts for vision model: First attempt: 15 seconds, second attempt: 25 seconds
            // Vision models need more time to process images and generate detailed responses
            const timeout = attempt === 1 ? 15000 : 25000;
            const timeoutId = setTimeout(() => controller.abort(), timeout);

            console.log(`${name} API attempt ${attempt} with ${timeout/1000}s timeout...`);

            // Prepare messages for vision model
            let messages = [
              { 
                role: "system", 
                content: "ржЖржкржирж┐ ржПржХржЬржи ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧ ржмрж┐рж╢рзЗрж╖ржЬрзНржЮред ржЧрж╛ржЫрзЗрж░ ржЫржмрж┐ ржжрзЗржЦрзЗ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ ржХрж░рзБржиред рж░рзЛржЧрзЗрж░ ржирж╛ржо, рж▓ржХрзНрж╖ржг, ржХрж╛рж░ржг ржПржмржВ ржЪрж┐ржХрж┐рзОрж╕рж╛ ржкржжрзНржзрждрж┐ ржмрж▓рзБржиред рж╕ржВржХрзНрж╖рзЗржкрзЗ ржХрж┐ржирзНрждрзБ рж╕ржорзНржкрзВрж░рзНржг ржЙрждрзНрждрж░ ржжрж┐ржиред" 
              },
              // Include recent chat history (last 6 messages to reduce token load further)
              ...(history && history.length > 0 ? history.slice(-6).map(msg => ({
                role: msg.role,
                content: msg.content
              })) : [])
            ];

            // Add user message with or without image
            if (image) {
              messages.push({
                role: "user",
                content: [
                  {
                    type: "text",
                    text: message || "ржПржЗ ржЧрж╛ржЫрзЗрж░ ржЫржмрж┐ ржмрж┐рж╢рзНрж▓рзЗрж╖ржг ржХрж░рзБржи ржПржмржВ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ ржХрж░рзБржи"
                  },
                  {
                    type: "image_url",
                    image_url: {
                      url: image
                    }
                  }
                ]
              });
            } else {
              messages.push({
                role: "user",
                content: message
              });
            }

            const res = await fetch("https://openrouter.ai/api/v1/chat/completions", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${key}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: "meta-llama/llama-3.2-11b-vision-instruct",
                messages: messages,
                max_tokens: 800,
                temperature: 0.3
              }),
              signal: controller.signal
            });

            clearTimeout(timeoutId);
            console.log(`${name} API Response Status:`, res.status);

            if (!res.ok) {
              const errorText = await res.text();
              console.error(`${name} API Error:`, errorText);

              // Extract reset time from headers if available
              let resetTime = null;
              const resetHeader = res.headers.get('X-RateLimit-Reset');
              if (resetHeader) {
                try {
                  // Convert Unix timestamp to Date
                  resetTime = new Date(parseInt(resetHeader));
                  console.log(`${name} API Reset time from header:`, resetTime);
                } catch (e) {
                  console.log('Error parsing reset header:', e.message);
                }
              }

              // Check for rate limit errors
              const rawErrorText = errorText.toLowerCase();
              if (rawErrorText.includes('rate limit') || 
                  rawErrorText.includes('limit exceeded') || 
                  rawErrorText.includes('free-models-per-day') ||
                  rawErrorText.includes('429')) {
                console.log(`Rate limit detected for ${name} key, trying next key...`);
                lastError = { 
                  type: 'rate_limit', 
                  message: errorText, 
                  key: name,
                  resetTime: resetTime
                };
                break; // Try next key
              }

              // Check for timeout errors (408)
              if (res.status === 408 || rawErrorText.includes('timeout')) {
                console.log(`Timeout detected for ${name} key on attempt ${attempt}`);
                if (attempt < 2) {
                  console.log(`Retrying ${name} key with longer timeout...`);
                  continue; // Try again with longer timeout
                } else {
                  lastError = { 
                    type: 'timeout', 
                    message: 'Request timeout after retries', 
                    key: name 
                  };
                  break; // Try next key
                }
              }

              // Check for service unavailable (503) or other server errors
              if (res.status >= 500) {
                console.log(`Server error (${res.status}) detected for ${name} key`);
                lastError = { 
                  type: 'server_error', 
                  message: `Server error: ${res.status}`, 
                  key: name,
                  status: res.status
                };
                break; // Try next key
              }

              // Try to parse JSON error response
              try {
                const errorData = JSON.parse(errorText);
                if (errorData.error && errorData.error.message) {
                  const errorMessage = errorData.error.message.toLowerCase();
                  if (errorMessage.includes('free-models-per-day') || 
                      errorMessage.includes('rate limit') || 
                      errorMessage.includes('limit exceeded') ||
                      errorMessage.includes('429')) {
                    console.log(`Rate limit detected for ${name} key in parsed JSON, trying next key...`);
                    lastError = { 
                      type: 'rate_limit', 
                      message: errorText, 
                      key: name,
                      resetTime: resetTime
                    };
                    break; // Try next key
                  }
                  
                  if (errorMessage.includes('timeout') || res.status === 408) {
                    console.log(`Timeout detected for ${name} key in parsed JSON on attempt ${attempt}`);
                    if (attempt < 2) {
                      console.log(`Retrying ${name} key with longer timeout...`);
                      continue; // Try again with longer timeout
                    } else {
                      lastError = { 
                        type: 'timeout', 
                        message: 'Request timeout after retries', 
                        key: name 
                      };
                      break; // Try next key
                    }
                  }
                }
              } catch (parseError) {
                // Continue with original error message if parsing fails
              }

              // For other errors, try next key
              lastError = { 
                type: 'api_error', 
                message: errorText, 
                key: name,
                status: res.status
              };
              break; // Try next key
            }

            // Success! Parse the response
            const data = await res.json();
            console.log(`${name} API Success:`, JSON.stringify(data).substring(0, 200) + '...');

            // Success! Return the response
            let responseContent = data.choices[0].message.content || "";
            
            // Handle response length and truncation
            if (data.choices[0].finish_reason === 'length') {
              console.log('Response was truncated by model, adding completion note');
              responseContent = responseContent.trim();
              if (!responseContent.endsWith('.')) {
                responseContent += '.';
              }
              responseContent += '\n\n(ржЙрждрзНрждрж░ржЯрж┐ рж╕ржорзНржкрзВрж░рзНржг ржиржпрж╝ - ржЖрж░ржУ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржЬрж╛ржирждрзЗ ржЖржмрж╛рж░ ржкрзНрж░рж╢рзНржи ржХрж░рзБржи)';
            } else {
              // Use our function to handle potentially long responses
              responseContent = handleLongResponse(responseContent);
            }
            
            // If response is very short and we have an image, suggest asking for more details
            if (image && responseContent.length < 100) {
              responseContent += '\n\nржЖрж░ржУ ржмрж┐рж╕рзНрждрж╛рж░рж┐ржд ржмрж┐рж╢рзНрж▓рзЗрж╖ржгрзЗрж░ ржЬржирзНржп "ржПржЗ ржЧрж╛ржЫрзЗрж░ рж░рзЛржЧрзЗрж░ ржЪрж┐ржХрж┐рзОрж╕рж╛ ржкржжрзНржзрждрж┐ ржмрж▓рзБржи" ржмрж╛ "рж░рзЛржЧрзЗрж░ ржХрж╛рж░ржг ржХрзА" ржПрж░ ржорждрзЛ ржкрзНрж░рж╢рзНржи ржХрж░рзБржиред';
            }

            return { success: true, response: responseContent, key: name };

          } catch (error) {
            clearTimeout(timeoutId);
            console.error(`${name} API Error:`, error.message);
            
            // Check for timeout errors in the catch block
            if (error.name === 'AbortError') {
              console.log(`Timeout detected for ${name} key on attempt ${attempt}`);
              if (attempt < 2) {
                console.log(`Retrying ${name} key with longer timeout...`);
                continue; // Try again with longer timeout
              } else {
                lastError = { type: 'timeout', message: 'Request timeout after retries', key: name };
                break; // Try next key
              }
            }
            
            // Check for rate limit errors in the catch block
            let errorMessage = error.message.toLowerCase();
            
            try {
              if (error.message.includes('{') && error.message.includes('}')) {
                const parsedError = JSON.parse(error.message);
                if (parsedError.error && parsedError.error.message) {
                  errorMessage = parsedError.error.message.toLowerCase();
                }
              }
            } catch (parseError) {
              // Continue with original error message if parsing fails
            }
            
            if (errorMessage.includes('rate limit') || 
                errorMessage.includes('limit exceeded') || 
                errorMessage.includes('free-models-per-day') ||
                errorMessage.includes('429')) {
              console.log(`Rate limit detected for ${name} key in catch block, trying next key...`);
              lastError = { type: 'rate_limit', message: error.message, key: name };
              break; // Try next key
            }
            
            if (error.response && error.response.status === 429) {
              console.log(`Rate limit detected for ${name} key via response status, trying next key...`);
              lastError = { type: 'rate_limit', message: error.message, key: name };
              break; // Try next key
            }
            
            // Network errors might be rate limit related
            if (error.code === 'ECONNRESET' || error.code === 'ENOTFOUND') {
              console.log(`Network error detected for ${name} key, might be rate limit related`);
              lastError = { type: 'rate_limit', message: error.message, key: name };
              break; // Try next key
            }
            
            lastError = { type: 'unknown', message: error.message, key: name };
            break; // Try next key
          }
        }
      }

      // If we get here, all keys failed
      throw lastError || new Error('All API keys failed');
    };

    // Check for local responses
    const normalizedMessage = message.toLowerCase().trim();
    
    console.log('Checking local responses for message:', normalizedMessage);
    console.log('Available local response keys:', Object.keys(localResponses));
    
    // Check exact matches first
    if (localResponses[normalizedMessage]) {
      console.log('Using local response for exact match:', normalizedMessage);
      return {
        statusCode: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          response: getRandomResponse(localResponses[normalizedMessage])
        })
      };
    }
    
    // Check for partial matches (e.g., "hello there" should match "hello", "it's raining" should match "raining")
    for (const [key, responses] of Object.entries(localResponses)) {
      if (key.length > 2) { // Only match words longer than 2 chars
        // Check if the key appears as a whole word in the message
        const wordBoundaryRegex = new RegExp(`\\b${key}\\b`, 'i');
        if (wordBoundaryRegex.test(normalizedMessage)) {
          console.log('Using local response for word match:', key, 'in message:', normalizedMessage);
          return {
            statusCode: 200,
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              response: getRandomResponse(responses)
            })
          };
        }
        
        // Also check for simple substring match as fallback
        if (normalizedMessage.includes(key)) {
          console.log('Using local response for substring match:', key, 'in message:', normalizedMessage);
          return {
            statusCode: 200,
            headers: {
              "Access-Control-Allow-Origin": "*",
              "Content-Type": "application/json"
            },
            body: JSON.stringify({
              response: getRandomResponse(responses)
            })
          };
        }
      }
    }
    
    console.log('No local response found, proceeding to API call');

    // Test mode - return simple response without API call
    if (process.env.TEST_MODE === 'true') {
      console.log('Running in test mode - skipping API call');
      return {
        statusCode: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          response: `Test mode: I received your message "${message}". This is a test response without calling the API.`
        })
      };
    }

    // Debug mode - return detailed error information
    if (process.env.DEBUG_MODE === 'true') {
      console.log('Running in debug mode');
      try {
        const debugResults = [];
        
        // Test primary key if available
        if (process.env.OPENROUTER_API_KEY && process.env.OPENROUTER_API_KEY.startsWith('sk-')) {
          try {
            const testRes = await fetch("https://openrouter.ai/api/v1/chat/completions", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: "mistralai/mistral-7b-instruct:free",
                messages: [
                  { role: "user", content: "Hi" }
                ],
                max_tokens: 20
              })
            });

            const errorText = await testRes.text();
            debugResults.push(`Primary Key: Status ${testRes.status}, Response: ${errorText.substring(0, 100)}`);
          } catch (error) {
            debugResults.push(`Primary Key: Error - ${error.message}`);
          }
        } else {
          debugResults.push('Primary Key: Not configured or invalid');
        }
        
        // Test backup key if available
        if (process.env.OPENROUTER_API_KEY_BACKUP && process.env.OPENROUTER_API_KEY_BACKUP.startsWith('sk-')) {
          try {
            const testRes = await fetch("https://openrouter.ai/api/v1/chat/completions", {
              method: "POST",
              headers: {
                "Authorization": `Bearer ${process.env.OPENROUTER_API_KEY_BACKUP}`,
                "Content-Type": "application/json"
              },
              body: JSON.stringify({
                model: "mistralai/mistral-7b-instruct:free",
                messages: [
                  { role: "user", content: "Hi" }
                ],
                max_tokens: 20
              })
            });

            const errorText = await testRes.text();
            debugResults.push(`Backup Key: Status ${testRes.status}, Response: ${errorText.substring(0, 100)}`);
          } catch (error) {
            debugResults.push(`Backup Key: Error - ${error.message}`);
          }
        } else {
          debugResults.push('Backup Key: Not configured or invalid');
        }
        
        return {
          statusCode: 200,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            response: `DEBUG: ${debugResults.join(' | ')}`
          })
        };
      } catch (debugError) {
        return {
          statusCode: 200,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({
            response: `DEBUG: Error: ${debugError.message}`
          })
        };
      }
    }

    // Make the API call with fallback
    console.log('Making API request with fallback...');
    
    try {
      const result = await makeApiCallWithFallback(message, history);
      
      console.log(`API call successful using ${result.key} key`);
      
      return {
        statusCode: 200,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({
          response: result.response
        })
      };

    } catch (error) {
      console.error('All API keys failed:', error);
      
      // Check if it's a rate limit error from all keys
      if (error.type === 'rate_limit') {
        return {
          statusCode: 429,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ 
            error: "Daily limit exceeded",
            response: "ржЖржорж┐ ржЖржЬ рж░рж╛рждрзЗ ржЦрзБржм ржХрзНрж▓рж╛ржирзНржд, ржЖржЧрж╛ржорзАржХрж╛рж▓ ржХржерж╛ рж╣ржмрзЗ ЁЯШ┤",
            resetTime: error.resetTime ? error.resetTime.toISOString() : null
          })
        };
      }
      
      // Handle timeout errors with a more helpful response
      if (error.type === 'timeout') {
        // Try to provide a contextual response based on the message
        let fallbackResponse = "ржжрзБржГржЦрж┐ржд, ржЖржорж┐ рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХрзЗрж░ ржЪрзЗржпрж╝рзЗ ржмрзЗрж╢рж┐ рж╕ржоржпрж╝ ржирж┐ржЪрзНржЫрж┐ред ржХржЦржиржУ ржХржЦржиржУ AI рж╕рж╛рж░рзНржнрж╛рж░ ржмрзНржпрж╕рзНржд ржерж╛ржХрж▓рзЗ ржПржоржи рж╣ржпрж╝ред ржХржпрж╝рзЗржХ рж╕рзЗржХрзЗржирзНржб ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи! ЁЯШК";
        
        // Check if we can provide a more specific response based on the message content
        const normalizedMessage = message ? message.toLowerCase().trim() : '';
        
        if (normalizedMessage.includes('rain') || normalizedMessage.includes('raining') || normalizedMessage.includes('ржмрзГрж╖рзНржЯрж┐')) {
          fallbackResponse = "ржмрзГрж╖рзНржЯрж┐рж░ ржжрж┐ржиржЧрзБрж▓рзЛ ржЖрж░рж╛ржоржжрж╛ржпрж╝ржХ рж╣рждрзЗ ржкрж╛рж░рзЗ! тШФ ржЧрж╛ржЫрзЗрж░ ржЫржмрж┐ ржЖржкрж▓рзЛржб ржХрж░рзЗ рж░рзЛржЧ ржирж┐рж░рзНржгржпрж╝ ржХрж░рж╛рж░ ржЬржирзНржп ржЙржкржпрзБржХрзНржд! ЁЯШК (ржирзЛржЯ: ржЖржорж╛рж░ AI ржорж╕рзНрждрж┐рж╖рзНржХ ржПржЦржи ржПржХржЯрзБ ржзрзАрж░, ржХрж┐ржирзНрждрзБ ржЖржорж┐ ржПржЦрж╛ржирзЗ ржЖржЫрж┐!)";
        } else if (normalizedMessage.includes('weather') || normalizedMessage.includes('ржЖржмрж╣рж╛ржУржпрж╝рж╛')) {
          fallbackResponse = "ржЖржорж┐ ржПржЦржи ржЖржмрж╣рж╛ржУржпрж╝рж╛ ржЪрзЗржХ ржХрж░рждрзЗ ржкрж╛рж░ржЫрж┐ ржирж╛, ржХрж┐ржирзНрждрзБ ржЖрж╢рж╛ ржХрж░рж┐ ржЖржкржирж╛рж░ ржЬрж╛ржпрж╝ржЧрж╛ржпрж╝ ржнрж╛рж▓рзЛ! ЁЯМдя╕П (ржЖржорж╛рж░ AI рж╕рж╛рж░рзНржнрж╛рж░ ржЖржЬ ржПржХржЯрзБ ржзрзАрж░!)";
        } else if (normalizedMessage.includes('hello') || normalizedMessage.includes('hi') || normalizedMessage.includes('hey') || normalizedMessage.includes('рж╣рзНржпрж╛рж▓рзЛ')) {
          fallbackResponse = "рж╣рзНржпрж╛рж▓рзЛ! ЁЯШК ржХрзЗржоржи ржЖржЫрзЗржи? (ржжрзБржГржЦрж┐ржд ржЖржорж┐ ржзрзАрж░рзЗ ржЙрждрзНрждрж░ ржжрж┐ржЪрзНржЫрж┐ - ржЖржорж╛рж░ AI ржорж╕рзНрждрж┐рж╖рзНржХ ржЕрждрж┐рж░рж┐ржХрзНржд ржмрзНржпрж╕рзНржд!)";
        } else if (normalizedMessage.includes('how are you') || normalizedMessage.includes('ржХрзЗржоржи ржЖржЫрзЗржи')) {
          fallbackResponse = "ржЖржорж┐ ржЦрзБржм ржнрж╛рж▓рзЛ! ржЬрж┐ржЬрзНржЮрзЗрж╕ ржХрж░рж╛рж░ ржЬржирзНржп ржзржирзНржпржмрж╛ржж! ржЖржкржирж┐ ржХрзЗржоржи? ЁЯШК (ржЖржорж╛рж░ ржЙрждрзНрждрж░ ржЖржЬ рж╕рж╛рж░рзНржнрж╛рж░ рж▓рзЛржбрзЗрж░ ржХрж╛рж░ржгрзЗ ржПржХржЯрзБ ржзрзАрж░!)";
        }
        
        return {
          statusCode: 408,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ 
            error: "Request timeout",
            response: fallbackResponse
          })
        };
      }
      
      // Handle server errors (5xx)
      if (error.type === 'server_error') {
        return {
          statusCode: 503,
          headers: {
            "Access-Control-Allow-Origin": "*",
            "Content-Type": "application/json"
          },
          body: JSON.stringify({ 
            error: "Service temporarily unavailable",
            response: "AI рж╕рж╛рж░рзНржнрж╛рж░ржЧрзБрж▓рж┐рждрзЗ ржПржЦржи ржХрж┐ржЫрзБ рж╕ржорж╕рзНржпрж╛ рж╣ржЪрзНржЫрзЗред ржХрж┐ржирзНрждрзБ ржЖржорж┐ ржПржЦржиржУ ржПржЦрж╛ржирзЗ ржЖржЫрж┐! ЁЯШК ржХржпрж╝рзЗржХ ржорж┐ржирж┐ржЯ ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи!"
          })
        };
      }
      
      // Handle other errors with a friendly fallback
      return {
        statusCode: 500,
        headers: {
          "Access-Control-Allow-Origin": "*",
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          error: "API Error",
          response: "ржПржЦржиржЗ рж╕ржВржпрзЛржЧ ржХрж░рждрзЗ рж╕ржорж╕рзНржпрж╛ рж╣ржЪрзНржЫрзЗ, ржХрж┐ржирзНрждрзБ ржЖржорж┐ ржПржЦржиржУ ржПржЦрж╛ржирзЗ ржЖржЫрж┐! ЁЯШК ржПржХржЯрзБ ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржи ржЕржержмрж╛ ржЕржирзНржп ржХрж┐ржЫрзБ ржирж┐ржпрж╝рзЗ ржХржерж╛ ржмрж▓рзБржи!"
        })
      };
    }

  } catch (error) {
    console.error('Unexpected error:', error.message, error.stack);
    
    return {
      statusCode: 500,
      headers: {
        "Access-Control-Allow-Origin": "*",
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ 
        error: "Internal server error",
        response: "ржЖржорж╛рж░ ржжрж┐ржХрзЗ ржХрж┐ржЫрзБ рж╕ржорж╕рзНржпрж╛ рж╣ржпрж╝рзЗржЫрзЗред ржПржХржЯрзБ ржкрж░рзЗ ржЖржмрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред"
      })
    };
  }
}; 